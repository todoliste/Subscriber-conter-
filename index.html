<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<title>Long Arm Game</title>
<style>
body {
    margin:0;
    background:#111;
    color:#fff;
    font-family:sans-serif;
    overflow:hidden;
}
#game {
    position:relative;
    width:100vw;
    height:100vh;
    overflow:hidden;
}
.arm {
    position:absolute;
    left:0;
    top:50%;
    width:8px;
    background:#fff;
    transform-origin:left center;
    border-radius:4px;
}
.door {
    position:absolute;
    width:40px;
    height:90px;
    background:#333;
    border:3px solid #999;
    border-radius:6px;
}
.knob {
    position:absolute;
    width:20px;
    height:20px;
    border-radius:50%;
    background:gold;
    right:-12px;
    top:35px;
}
.obstacle {
    position:absolute;
    width:40px;
    height:40px;
    background:red;
    border-radius:8px;
}
.coin {
    position:absolute;
    width:28px;
    height:28px;
    background:gold;
    border-radius:50%;
    box-shadow:0 0 10px gold;
}
#ui {
    position:absolute;
    top:10px;
    left:10px;
    font-size:20px;
}
#buySkinBtn {
    position:absolute;
    right:10px;
    top:10px;
    background:#333;
    color:#fff;
    padding:10px 15px;
    border-radius:6px;
    font-size:18px;
}
</style>
</head>
<body>
<div id="game"></div>
<div id="ui"></div>
<button id="buySkinBtn">Boutique</button>

<script>
const MAX_LEVELS = 100;
let level = Number(localStorage.getItem("level")||1);
let coins = Number(localStorage.getItem("coins")||0);
let equippedSkin = localStorage.getItem("skin") || "default";

// SKINS dispo (tous ceux que tu as valid√©s)
const SKINS = {
    "default": {name:"Par d√©faut", price:0, color:"#fff"},
    "rainbow": {name:"Arc-en-ciel", price:200, color:"linear-gradient(90deg,red,orange,yellow,green,cyan,blue,violet)"},
    "fire": {name:"Feu", price:300, color:"#ff4500"},
    "electric": {name:"Electrique", price:300, color:"#00ffff"},
    "gold": {name:"Dor√©", price:500, color:"gold"},
    "skeleton": {name:"Squelette", price:350, color:"#ddd"},
    "slime": {name:"Slime", price:250, color:"#00ff66"},
    "chrome": {name:"Chrome", price:400, color:"#ccc"},
    "galaxy": {name:"Galaxie", price:450, color:"purple"}
};

const game = document.getElementById("game");

function save(){
    localStorage.setItem("level",level);
    localStorage.setItem("coins",coins);
    localStorage.setItem("skin",equippedSkin);
}

function updateUI(){
    document.getElementById("ui").innerHTML =
        "Niveau : "+level+" / 100<br>üí∞ Coins : "+coins;
}

function genLevelConfig(i){
    // difficult√© progressive
    const diff = i / MAX_LEVELS;
    const doorX = 200 + diff * 500;
    const knobOffsetY = (Math.sin(i)*60)-30;
    const tolerance = 40 - diff*25;

    return {doorX, knobOffsetY, tolerance};
}

function spawnObstacles(level){
    let diff = level/MAX_LEVELS;
    let count = Math.floor(2 + diff*4);

    for(let i=0;i<count;i++){
        let o = document.createElement("div");
        o.className="obstacle";
        o.style.left = (100 + Math.random()*500)+"px";
        o.style.top = (Math.random()*(window.innerHeight-80))+"px";
        game.appendChild(o);
    }
}

function spawnCoin(level){
    let c = document.createElement("div");
    c.className="coin";
    c.style.left = (200 + Math.random()*400)+"px";
    c.style.top = (100 + Math.random()*(window.innerHeight-200))+"px";
    game.appendChild(c);
}

function playLevel(){
    game.innerHTML="";
    updateUI();

    const L = genLevelConfig(level);

    // Door
    let door = document.createElement("div");
    door.className="door";
    door.style.left = L.doorX+"px";
    door.style.top = "50%";
    game.appendChild(door);

    let knob = document.createElement("div");
    knob.className="knob";
    knob.style.top = (35 + L.knobOffsetY) + "px";
    door.appendChild(knob);

    // Arm
    let arm = document.createElement("div");
    arm.className="arm";
    if(SKINS[equippedSkin].color.includes("gradient"))
        arm.style.background = SKINS[equippedSkin].color;
    else
        arm.style.background = SKINS[equippedSkin].color;
    game.appendChild(arm);

    spawnObstacles(level);
    spawnCoin(level);

    // Control
    game.onmousemove = e =>{
        let dx = e.clientX;
        let dy = e.clientY - window.innerHeight/2;
        let dist = Math.sqrt(dx*dx + dy*dy);
        arm.style.width = dist+"px";
        arm.style.transform = `rotate(${Math.atan2(dy,dx)}rad)`;

        checkCollision(arm, knob, L.tolerance);
    };
}

function box(r){return r.getBoundingClientRect();}

function checkCollision(arm, knob, tolerance){
    // collision pi√®ce
    let coin = document.querySelector(".coin");
    if(coin){
        let a=box(arm), c=box(coin);
        if(a.right>c.left && a.left<c.right && a.bottom>c.top && a.top<c.bottom){
            coin.remove();
            coins+=5;
            save();
            updateUI();
        }
    }

    // collision obstacle
    for(let o of document.querySelectorAll(".obstacle")){
        let a=box(arm), b=box(o);
        if(a.right>b.left && a.left<b.right && a.bottom>b.top && a.top<b.bottom){
            // reset level
            playLevel();
            return;
        }
    }

    // succ√®s : toucher la poign√©e
    let a=box(arm), k=box(knob);
    if(a.right>k.left-tolerance && a.left<k.right+tolerance &&
       a.bottom>k.top-tolerance && a.top<k.bottom+tolerance){

        level++;
        if(level>MAX_LEVELS) level=MAX_LEVELS;
        save();
        playLevel();
    }
}

playLevel();
</script>// ------------------------------
// ‚≠ê BOUTIQUE SIMPLE (PARTIE 2)
// ------------------------------

let shopOpen = false;

// UI de la boutique (fen√™tre modale)
const shopDiv = document.createElement("div");
shopDiv.style.position = "absolute";
shopDiv.style.top = "0";
shopDiv.style.left = "0";
shopDiv.style.width = "100vw";
shopDiv.style.height = "100vh";
shopDiv.style.background = "rgba(0,0,0,0.8)";
shopDiv.style.display = "none";
shopDiv.style.zIndex = "999";
shopDiv.style.padding = "20px";
shopDiv.style.overflowY = "auto";
shopDiv.style.textAlign = "center";
shopDiv.innerHTML = "<h1 style='margin-top:20px'>üõí Boutique</h1>";
document.body.appendChild(shopDiv);

// Bouton pour ouvrir la boutique
document.getElementById("buySkinBtn").onclick = () => {
    shopOpen = !shopOpen;
    shopDiv.style.display = shopOpen ? "block" : "none";
    if(shopOpen) renderShop();
};

function renderShop(){
    shopDiv.innerHTML = "<h1 style='margin-top:20px'>üõí Boutique</h1>";
    shopDiv.innerHTML += "<p style='font-size:20px'>Coins : "+coins+" üí∞</p>";

    for(let id in SKINS){
        let sk = SKINS[id];
        let owned = localStorage.getItem("owned_"+id) === "true";

        let item = document.createElement("div");
        item.style.background = "#222";
        item.style.margin = "10px auto";
        item.style.padding = "15px";
        item.style.borderRadius = "10px";
        item.style.width = "80%";

        item.innerHTML = `
            <h2>${sk.name}</h2>
            <div style="
                margin:10px auto;
                width:80px;
                height:12px;
                border-radius:6px;
                background:${sk.color.includes("gradient") ? sk.color : sk.color};
                box-shadow:0 0 10px #fff;
            "></div>
            <p>Prix : ${sk.price} üí∞</p>
        `;

        let btn = document.createElement("button");
        btn.style.padding = "10px 20px";
        btn.style.marginTop = "10px";
        btn.style.borderRadius = "6px";
        btn.style.border = "none";
        btn.style.fontSize = "16px";
        btn.style.color = "#fff";
        btn.style.cursor = "pointer";

        if(owned){
            if(equippedSkin === id){
                btn.innerText = "√âquip√© ‚úîÔ∏è";
                btn.style.background = "#555";
            } else {
                btn.innerText = "√âquiper";
                btn.style.background = "#4caf50";
                btn.onclick = ()=>{
                    equippedSkin = id;
                    save();
                    renderShop();
                    playLevel();
                };
            }

        } else {
            btn.innerText = "Acheter";
            btn.style.background = "#1976d2";
            btn.onclick = ()=>{
                if(coins >= sk.price){
                    coins -= sk.price;
                    localStorage.setItem("owned_"+id, "true");
                    save();
                    renderShop();
                } else {
                    alert("Pas assez de coins !");
                }
            };
        }

        item.appendChild(btn);
        shopDiv.appendChild(item);
    }

    // Bouton fermer
    let close = document.createElement("button");
    close.innerText = "Fermer";
    close.style.padding = "10px 20px";
    close.style.margin = "20px";
    close.style.background = "#444";
    close.style.color = "#fff";
    close.style.borderRadius = "6px";
    close.onclick = ()=>{
        shopOpen = false;
        shopDiv.style.display = "none";
    };
    shopDiv.appendChild(close);
}// ------------------------------
// ‚≠ê PARTIE 3 ‚Äî EFFETS VISUELS & SONS
// (√† coller AVANT </script>)
// ------------------------------

/* FX canvas (overlay) */
const fxCanvas = document.createElement('canvas');
fxCanvas.style.position = 'absolute';
fxCanvas.style.left = '0';
fxCanvas.style.top = '0';
fxCanvas.style.pointerEvents = 'none';
fxCanvas.style.zIndex = 999;
document.getElementById('game').appendChild(fxCanvas);
const fctx = fxCanvas.getContext('2d');

function resizeFx() {
  const r = document.getElementById('game').getBoundingClientRect();
  fxCanvas.width = r.width;
  fxCanvas.height = r.height;
  fxCanvas.style.width = r.width + 'px';
  fxCanvas.style.height = r.height + 'px';
  fxCanvas.style.left = r.left + 'px';
  fxCanvas.style.top = r.top + 'px';
}
window.addEventListener('resize', resizeFx);
resizeFx();

/* Particle system */
let particles = [];
function spawnParticle(x,y,dx,dy,color,life=600,size=6){
  particles.push({x,y,dx,dy,color,life,age:0,size});
}
function updateParticles(dt){
  for(let i=particles.length-1;i>=0;i--){
    let p = particles[i];
    p.age += dt;
    p.x += p.dx * dt/16;
    p.y += p.dy * dt/16;
    p.dx *= 0.995; p.dy *= 0.995;
    if(p.age > p.life) particles.splice(i,1);
  }
}
function drawParticles(){
  fctx.clearRect(0,0,fxCanvas.width,fxCanvas.height);
  for(const p of particles){
    const alpha = 1 - (p.age / p.life);
    fctx.globalAlpha = alpha;
    fctx.beginPath();
    fctx.fillStyle = p.color;
    fctx.arc(p.x, p.y, Math.max(0.6, p.size * (1 - p.age / p.life)), 0, Math.PI*2);
    fctx.fill();
  }
  fctx.globalAlpha = 1;
}

/* Utility: get arm base & tip coords (based on .arm element with transform) */
function getArmEndpoints(){
  const armEl = document.querySelector('.arm');
  if(!armEl) return null;
  const rect = armEl.getBoundingClientRect();
  // transform matrix for rotated element
  const s = window.getComputedStyle(armEl);
  const tr = s.transform;
  // default: no transform -> matrix(1,0,0,1,0,0)
  let a=1,b=0,c=0,d=1,tx=0,ty=0;
  if(tr && tr !== 'none'){
    const m = tr.match(/matrix\(([-0-9.,e ]+)\)/);
    if(m){
      const parts = m[1].split(',').map(x=>parseFloat(x));
      [a,b,c,d,tx,ty] = parts;
    } else {
      const m3 = tr.match(/matrix3d\(([-0-9.,e ]+)\)/);
      if(m3){ const parts = m3[1].split(',').map(x=>parseFloat(x)); a=parts[0]; b=parts[1]; c=parts[4]; d=parts[5]; tx=parts[12]; ty=parts[13]; }
    }
  }
  // base is left edge center
  const baseX = rect.left;
  const baseY = rect.top + rect.height/2;
  // width is rect.width, rotated by matrix a,b
  const tipX = baseX + a * rect.width;
  const tipY = baseY + b * rect.width;
  // convert to fxCanvas coordinates (relative to game container)
  const gameRect = document.getElementById('game').getBoundingClientRect();
  return {
    baseX: baseX - gameRect.left,
    baseY: baseY - gameRect.top,
    tipX: tipX - gameRect.left,
    tipY: tipY - gameRect.top
  };
}

/* Trail: spawn small particles while moving */
let lastTip = null;
let lastTime = performance.now();
function updateTrail(){
  const endpoints = getArmEndpoints();
  if(!endpoints) return;
  const now = performance.now();
  const dt = now - lastTime;
  lastTime = now;
  if(lastTip){
    const dx = endpoints.tipX - lastTip.x;
    const dy = endpoints.tipY - lastTip.y;
    const dist = Math.hypot(dx,dy);
    if(dist > 2){
      const skinColor = getSkinColor(selectedSkin) || '#ffb86b';
      // spawn 1-3 particles along path
      const count = Math.min(4, Math.ceil(dist/6));
      for(let i=0;i<count;i++){
        const t = i/count;
        const px = lastTip.x + dx*t;
        const py = lastTip.y + dy*t;
        spawnParticle(px,py, (Math.random()-0.5)*0.6, (Math.random()-0.5)*0.6, skinColor, 450, 4 + Math.random()*4);
      }
    }
  }
  lastTip = {x:endpoints.tipX, y:endpoints.tipY};
}

/* Events: coin pickup / success / fail / equip visual */
function onCoinPickup(x,y){
  // create spark particles + sound
  for(let i=0;i<14;i++){
    const ang = Math.random()*Math.PI*2;
    const spd = 0.6 + Math.random()*2.6;
    spawnParticle(x,y, Math.cos(ang)*spd, Math.sin(ang)*spd, '#ffd166', 700, 4 + Math.random()*6);
  }
  playCoinSound();
}
function onLevelSuccess(x,y){
  // star burst + sound
  for(let i=0;i<30;i++){
    const ang = Math.random()*Math.PI*2;
    const spd = 1 + Math.random()*4;
    const color = (Math.random()>0.6) ? '#ffd700' : '#ffffff';
    spawnParticle(x,y, Math.cos(ang)*spd, Math.sin(ang)*spd, color, 1000, 5 + Math.random()*6);
  }
  playSuccessSound();
}
function onFail(x,y){
  for(let i=0;i<12;i++){
    const ang = Math.random()*Math.PI*2;
    const spd = 0.6 + Math.random()*2.2;
    spawnParticle(x,y, Math.cos(ang)*spd, Math.sin(ang)*spd, '#ff6b6b', 700, 4 + Math.random()*4);
  }
  playFailSound();
}
function onEquip(x,y){
  for(let i=0;i<24;i++){
    const ang = Math.random()*Math.PI*2;
    const spd = 0.6 + Math.random()*2.4;
    spawnParticle(x,y, Math.cos(ang)*spd, Math.sin(ang)*spd, getSkinColor(selectedSkin) || '#fff', 800, 5 + Math.random()*5);
  }
  playEquipSound();
  // small CSS flash on button
  const btn = document.getElementById('buySkinBtn');
  btn.animate([{transform:'scale(1)'},{transform:'scale(1.08)'},{transform:'scale(1)'}], {duration:350, easing:'ease-out'});
}

/* Hook into game actions */
/* - We cannot modify existing internal functions, so we watch DOM changes and user interactions.
   - Coin pickup: observe removal of .coin element -> trigger onCoinPickup
   - Level success: when LEVEL increases -> trigger onLevelSuccess
   - Fail: when obstacles cause reload (we detect by message 'Touch√©' or 'Recommence' or quick arm reset) -> heuristic: watch for rapid playLevel calls
*/

let lastLevelObserved = level;
let lastPlayCall = performance.now();
const origPlayLevel = window.playLevel || null;
if(origPlayLevel){
  // wrap playLevel to detect success/fail calls
  window.playLevel = function(){
    const prevLevel = level;
    lastPlayCall = performance.now();
    // call original
    origPlayLevel();
    // after a short delay, check if level changed (success)
    setTimeout(()=>{
      if(level > prevLevel){
        // success ‚Äî compute center near knob
        const gameRect = document.getElementById('game').getBoundingClientRect();
        const knob = document.querySelector('.knob');
        if(knob){
          const kRect = knob.getBoundingClientRect();
          onLevelSuccess((kRect.left + kRect.right)/2 - gameRect.left, (kRect.top + kRect.bottom)/2 - gameRect.top);
        } else {
          onLevelSuccess(fxCanvas.width/2, fxCanvas.height/2);
        }
      }
    }, 140);
  };
}

/* Observe coin removals to trigger coin fx */
const coinObserver = new MutationObserver((mutations)=>{
  for(const m of mutations){
    for(const rem of m.removedNodes){
      if(rem.classList && rem.classList.contains && rem.classList.contains('coin')){
        // compute its last known position via bounding rect before removal is tricky;
        // fallback: use current mouse tip pos
        const ep = getArmEndpoints();
        const x = ep ? ep.tipX : fxCanvas.width/2;
        const y = ep ? ep.tipY : fxCanvas.height/2;
        onCoinPickup(x,y);
      }
    }
  }
});
coinObserver.observe(game, { childList:true, subtree:true });

/* Listen for fails: we wrap checkCollision if present */
if(window.checkCollision && typeof window.checkCollision === 'function'){
  const origCheck = window.checkCollision;
  window.checkCollision = function(arm, knob, tolerance){
    // call original and capture state: if it resets level quickly -> fail
    origCheck(arm, knob, tolerance);
    // heuristic: if arm length reset to near 40 shortly after a collision check, assume fail
    const ep = getArmEndpoints();
    // small timeout to sample
    setTimeout(()=>{
      const aEl = document.querySelector('.arm');
      if(aEl){
        const rect = aEl.getBoundingClientRect();
        if(rect.width < 60){
          // fail effect at tip
          const tip = getArmEndpoints();
          if(tip) onFail(tip.tipX, tip.tipY);
        }
      }
    }, 80);
  };
}

/* Hook shop equip / buy to play sounds and spawn particles */
(function hookShopButtons(){
  // delegate click on document for buttons inside shopDiv
  document.addEventListener('click', (ev)=>{
    const btn = ev.target;
    if(!btn) return;
    // buy button: contains 'Acheter' text
    if(btn.innerText && btn.innerText.includes('Acheter')){
      playBuySound();
      const ep = getArmEndpoints();
      if(ep) onEquip(ep.tipX, ep.tipY);
    }
    if(btn.innerText && (btn.innerText.includes('√âquiper') || btn.innerText.includes('√âquip√©'))){
      // equip effect
      setTimeout(()=>{
        const ep = getArmEndpoints();
        if(ep) onEquip(ep.tipX, ep.tipY);
      }, 40);
    }
  });
})();

/* Animation loop for FX */
let lastFX = performance.now();
function fxLoop(t){
  const dt = t - lastFX; lastFX = t;
  updateParticles(dt);
  updateTrail();
  drawParticles();
  requestAnimationFrame(fxLoop);
}
requestAnimationFrame(fxLoop);

/* ---------------------------
   WebAudio simple synth sounds
   --------------------------- */
const AudioCtx = (window.AudioContext || window.webkitAudioContext);
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx){ audioCtx = new AudioCtx(); }
}
function playCoinSound(){
  ensureAudio();
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(880, now);
  o.frequency.exponentialRampToValueAtTime(1100, now+0.08);
  g.gain.setValueAtTime(0.001, now);
  g.gain.exponentialRampToValueAtTime(0.12, now+0.02);
  g.gain.exponentialRampToValueAtTime(0.001, now+0.32);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(now); o.stop(now+0.35);
}
function playSuccessSound(){
  ensureAudio();
  const now = audioCtx.currentTime;
  const o1 = audioCtx.createOscillator();
  const o2 = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o1.type = 'sine'; o2.type = 'triangle';
  o1.frequency.setValueAtTime(600, now); o2.frequency.setValueAtTime(900, now);
  g.gain.setValueAtTime(0.001, now);
  g.gain.linearRampToValueAtTime(0.16, now+0.02);
  g.gain.exponentialRampToValueAtTime(0.001, now+0.9);
  o1.connect(g); o2.connect(g); g.connect(audioCtx.destination);
  o1.start(now); o2.start(now);
  o1.stop(now+0.9); o2.stop(now+0.9);
}
function playFailSound(){
  ensureAudio();
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sawtooth';
  o.frequency.setValueAtTime(220, now);
  o.frequency.exponentialRampToValueAtTime(90, now+0.18);
  g.gain.setValueAtTime(0.001, now);
  g.gain.linearRampToValueAtTime(0.18, now+0.02);
  g.gain.exponentialRampToValueAtTime(0.001, now+0.45);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(now); o.stop(now+0.45);
}
function playBuySound(){
  ensureAudio();
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'square';
  o.frequency.setValueAtTime(440, now);
  o.frequency.exponentialRampToValueAtTime(660, now+0.08);
  g.gain.setValueAtTime(0.001, now);
  g.gain.exponentialRampToValueAtTime(0.14, now+0.02);
  g.gain.exponentialRampToValueAtTime(0.001, now+0.28);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(now); o.stop(now+0.35);
}
function playEquipSound(){
  ensureAudio();
  const now = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = 'sine';
  o.frequency.setValueAtTime(720, now);
  o.frequency.exponentialRampToValueAtTime(1100, now+0.12);
  g.gain.setValueAtTime(0.001, now);
  g.gain.linearRampToValueAtTime(0.16, now+0.02);
  g.gain.exponentialRampToValueAtTime(0.001, now+0.5);
  o.connect(g); g.connect(audioCtx.destination);
  o.start(now); o.stop(now+0.6);
}

/* Small accessibility: enable audio after first user gesture */
document.addEventListener('pointerdown', function initAudioOnce(){
  ensureAudio();
  document.removeEventListener('pointerdown', initAudioOnce);
}, {once:true});

/* Hook into existing message and coin logic:
   - When coins change, spawn coin fx near arm tip
*/
let prevCoins = coins;
setInterval(()=>{
  if(coins > prevCoins){
    const ep = getArmEndpoints();
    if(ep) onCoinPickup(ep.tipX, ep.tipY);
    prevCoins = coins;
  } else if(coins < prevCoins){
    prevCoins = coins;
  }
}, 250);

/* Provide small API for external triggers if needed */
window.fx = {
  spawnParticle,
  onCoinPickup,
  onLevelSuccess,
  onFail,
  onEquip
};

// fin PARTIE 3