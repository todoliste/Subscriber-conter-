<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Voice Changer + Download (pitch shift)</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; background: #f5f5f5; }
    button, input { margin: 5px; padding: 8px; font-size: 16px; }
    audio { display: block; margin-top: 15px; width: 100%; }
  </style>
</head>
<body>
  <h2>Voice Changer + T√©l√©charger (pitch shift)</h2>
  <button id="startBtn">üé§ D√©marrer l'enregistrement</button>
  <button id="stopBtn" disabled>‚èπ Arr√™ter</button>
  <br>

  <label for="pitch">Pitch (hauteur) :</label>
  <input type="range" id="pitch" min="-12" max="12" step="1" value="0"> <!-- demi‚Äëtons -->
  <span id="pitchValue">0</span> demi‚Äëtons

  <p>Apr√®s enregistrement : √©coute + t√©l√©charger</p>
  <audio id="player" controls></audio>
  <a id="downloadLink" href="#" download="voice_changed.wav">T√©l√©charger le fichier modifi√©</a>

<script src="https://cdn.jsdelivr.net/npm/soundbank-pitch-shift/dist/pitch-shift.min.js"></script>
<script>
(async () => {
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const pitchSlider = document.getElementById('pitch');
  const pitchValue = document.getElementById('pitchValue');
  const player = document.getElementById('player');
  const downloadLink = document.getElementById('downloadLink');

  let audioContext, mediaStream, mediaRecorder, chunks = [];

  let pitchShiftNode;

  startBtn.onclick = async () => {
    mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    audioContext = new (window.AudioContext || window.webkitAudioContext)();

    const source = audioContext.createMediaStreamSource(mediaStream);
    pitchShiftNode = soundbankPitchShift(audioContext);
    source.connect(pitchShiftNode);
    pitchShiftNode.connect(audioContext.destination);

    // Pour enregistrer l'audio modifi√© : on cr√©e un dest pour MediaRecorder
    const dest = audioContext.createMediaStreamDestination();
    pitchShiftNode.connect(dest);

    mediaRecorder = new MediaRecorder(dest.stream);
    mediaRecorder.ondataavailable = e => chunks.push(e.data);
    mediaRecorder.start();

    startBtn.disabled = true;
    stopBtn.disabled = false;
    chunks = [];

    // Optionnel : arr√™t automatique au bout de 10 min
    setTimeout(() => {
      if (mediaRecorder.state === 'recording') stopBtn.click();
    }, 10 * 60 * 1000);
  };

  stopBtn.onclick = () => {
    mediaRecorder.stop();
    mediaStream.getTracks().forEach(t => t.stop());
    audioContext.close();
    startBtn.disabled = false;
    stopBtn.disabled = true;
  };

  pitchSlider.oninput = () => {
    pitchValue.textContent = pitchSlider.value;
    if (pitchShiftNode) {
      pitchShiftNode.transpose = parseInt(pitchSlider.value, 10);
    }
  };

  mediaRecorder && (mediaRecorder.onstop = () => {
    const blob = new Blob(chunks, { type: 'audio/wav' });
    const url = URL.createObjectURL(blob);
    player.src = url;
    downloadLink.href = url;
  });

  // Important : r√©assigner onstop apr√®s cr√©ation
  const originalOnStop = () => {
    const blob = new Blob(chunks, { type: 'audio/wav' });
    const url = URL.createObjectURL(blob);
    player.src = url;
    downloadLink.href = url;
  };
  if (mediaRecorder) mediaRecorder.onstop = originalOnStop;
})();
</script>
</body>
</html>